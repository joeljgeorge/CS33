1) Compiling with -O2
This is the shortest of them all. The compiler simply realizes that n plus any non-zero value, no matter how great or how small, will never be equal to the original value of n. Thus, the compiler simply exclusive ors eax with itself, guaranteeing that the return value is 0, or false. This is smart, because you don't have to factor in undefined behaviors - with this optimization, you simply apply the mathematical truth of the expression to produce a clean, quick result. 

2)Compiling with -O2 -fwrapv
This assembly language file is also pretty short, but it is longer than the first file. Essentially, it adds 9223372036854775807 to rax, and then adds rdi to rax. This represents n + 9223372036854775807. Then it compares rdi and rax (this represents n + 9223372036854775807 < n). In doing this comparison command, it sets the SF and OF flags, which are used in the final command (setl). This checks if SF and OF are equal. If they are not equal that means that either one of two things a) n - (n + 9223372036854775807) resulted in a negative number, or the difference is 0. The first of these cases seems obvious, but the second one is just as necessary, because fwrapv allows for overflow, which may result in  n + 9223372036854775807 equalling n. That's why this assembly language file is slightly longer than it's predecessor - it has to account for the potential effects of overflow wrapping. 

3)Compiling with -O2 -fsanitize=undefined
This has by far the most assembly code. fsanitize=undefined essentially just adds a function called __ubsan_handle_add_overflow, which has some further code to support it (all the code under the section .Lubsan_data0). Although I do not know the code for __ubsan_handle_add_overflow, I assume that it just makes sure that the correct flags (mainly the overflow flag) are reset and that the overflow is handled neatly (wrapping has not been explicitly enabled, so fsanitize=undefined steps in to prevent undefined behavior from occuring). The way this assembly code works is that it first saves the values of rbp and rbx on the stack, and then moves 9223372036854775807 into rdx. Next, it moves n into rbp and rbx, adding a bit more room on the stack after that to accomodate some more variables (presumably from __ubsan_handle_add_overflow). Then it adds rdx (9223372036854775807) to rbp (n), thus giving us n + 9223372036854775807 in rbp. Now, it checks if the overflow flag has been set (i.e. n + 9223372036854775807 overflowed) - if it has, the function goes into the section that has __ubsan_handle_add_overflow, to prevent any action based on undefined behavior. Once this has been handled, control is passed back to the normal function, and the function compares rbx (n) and rbp (n + 9223372036854775807). If the zero flag and overflow flag have the same sign, then rax is set to 1. Otherwise, rax is 0, and the function clears the stack before returning this value. 

